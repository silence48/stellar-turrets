{
    "function": "const {\n    Server,\n    TransactionBuilder,\n    Asset,\n    Networks,\n    Operation  \n} = require(\"stellar-sdk\")\nconst fetch = require('node-fetch');\n\n\n// Defining Public key of issuer, and pool account -- for this collection they are the same for each saNFT\nconst issuerPK = \"GA27NNOZBDH47SLV4ZTNLUUKBO7MIHRAA3XGLFRE6SX6X2V5SKHAWLAB\"\nconst poolPK = \"GCUH5CLBY5TAW7MKIN3T7MO3RARF2JAQSAVGCI2YDTIVVO2QAHUQ46GC\"\n\nconst mixedFeePercentage = 20 // 20% of the total amount of the buy_offer -- this will be the \"mixedFee\"\nconst poolAmountPercentage = 75 // 75% of the mixedFee(15% of buy offer) will be sent to the pool account, the highest the poolAmountPercentage, the more the pool account will receive the less the artist(me) earns and the more volume there will be for that saNFT.\n\nconst server = new Server(HORIZON_URL)\n\n// Assigning the id to each saNFT\nconst HorusCollection = [{\n    \"saHorusNFT0\": \"61b0b20b62ed886f915c5cf3\",\n    \"saHorusNFT1\": \"61b0b22201558c731cd0815b\",\n    \"saHorusNFT2\": \"61b0b22e01558c731cd08163\",\n    \"saHorusNFT3\": \"61b0b23901558c731cd0816d\",\n}]\n\n\n// this function returns the number of saNFTs the UserPK owns\nasync function getMultipleOwners(ownerPK) {\n    const acc_data = await (await server.accounts().accountId(issuerPK).call()).data_attr\n    const own_nfts = Object.keys(acc_data).filter(key => key.startsWith(ownerPK))\n    \n    return (own_nfts.length).toString()\n}\n\n// This function will make a call to my worker, which will upload the (saNFT)+#owner_seq to IPFS and return the hash\nasync function loadToIPFS(curr_own_seq, code, id) {\n    const data = {\n        \"code\": code,\n        \"id\": id,\n        \"n_owner\": curr_own_seq\n    }\n\n    // make a fetch post request to an endpoint with data as body\n    const response = await fetch('https://smartists.tdep.workers.dev/ipfs/upload', {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    })\n    const json = await response.json()\n    return json.IpfsHash\n}\n\n\n// Building the list of owners, will be used to make the payment to each owner. Returns an array of objects with the ownerPK and the percentage of the owned saNFT network of that owner.\nasync function buildOwnersList(saNFT) {\n    const trades = await server.trades().forAssetPair(saNFT, Asset.native()).limit(92).order(\"desc\").call()\n    let owners = []\n    let records = trades.records\n    const totSupply = records.map(x => parseInt(x.counter_amount))\n    console.log(totSupply)\n    const sumTotalSupply = Math.round((totSupply.reduce((a, b) => a + b, 0)) * 1000000) / 1000000\n    for (let i=0; i < records.length; i++) {\n        owners.push({\n          \"ownerPK\":records[i].counter_account,\n          \"ownPerc\": (parseFloat(records[i].counter_amount) * parseFloat(100)) / sumTotalSupply\n        })     \n    }\n    owners = owners.sort((a, b) => (a.ownPerc < b.ownPerc) ? 1 : -1) // sorting the array of objects by the percentage of the owned saNFT network of that owner.\n    if (owners.length > 92) { // if the number of owners is greater than 92, we will take the top 92 owners\n      owners.splice(93, owners.length)\n    } \n    return owners\n  }\n \n\n\nmodule.exports = async(body) => {\n    let saNFT;\n    const {\n        userPK,\n        fee,\n        time_bounds,\n        buy_offer,\n        saNFT_id,\n    } = body\n    \n    const collection_keys = HorusCollection.map(x => Object.keys(x))[0] \n    if (collection_keys.includes(saNFT_id) === true) { // validating the provided saNFT_id\n        saNFT = new Asset(saNFT_id, issuerPK)\n    } else {\n        throw new Error(\"saNFT_id is not valid\")\n    }\n    const mixedFee = (buy_offer * mixedFeePercentage) / 100 // Defining the mixedFee based on the % defined at line:14\n    const artistFee = (mixedFee * (100-poolAmountPercentage)) / 100 // this amount is never sent to anyone, but it's the amount of the buy_offer that remains to the artist (issuer) after paying all the owners and the pool fund. \n    const poolAmount = (mixedFee * poolAmountPercentage) / 100 // Defining the poolAmount based on the % defined at line:15\n    const owners = await buildOwnersList(saNFT)\n    const curr_own_seq = owners.length + 1 // the current owner sequence, AKA the number of issued saNFT_id + 1\n    const saNFTID = HorusCollection.map(x => {\n        if (Object.keys(x).includes(saNFT_id)) {\n            return x[saNFT_id]\n        }\n    })[0]\n    const saNFT_hash = await loadToIPFS(curr_own_seq, saNFT_id, saNFTID) // upload the data for the saNFT#owner_seq to IPFS, get the hash\n    const user_owned_sanfts = await getMultipleOwners(userPK) // get the number of saNFTs owned by the user\n\n    const account = await server.loadAccount(issuerPK)\n    let transaction = new TransactionBuilder(account, {\n        fee: fee,\n        timebounds: time_bounds,\n        networkPassphrase: Networks[STELLAR_NETWORK]\n    })\n        .addOperation(Operation.changeTrust({\n            asset: saNFT,\n            limit: \"1\",\n            source: userPK\n        }))\n        .addOperation(Operation.setTrustLineFlags({\n            trustor: userPK,\n            asset: saNFT,\n            flags: {\n                authorized: true\n            }            \n        }))\n        .addOperation(Operation.manageSellOffer({\n            selling: saNFT,\n            buying: Asset.native(),\n            amount: \"1\",\n            price: buy_offer\n        }))\n        // the buyer(userPK) will pay the issuer(issuerPK) the buy amount. Then the issuer will handle those XLM (paying the owners, funding the pool, and keeping the artistFee(as issuer is the artist))\n        .addOperation(Operation.manageBuyOffer({\n            selling: Asset.native(),\n            buying: saNFT,\n            buyAmount: \"1\",\n            price: buy_offer,\n            source: userPK\n        }))\n        .addOperation(Operation.setTrustLineFlags({\n            trustor: userPK,\n            asset: saNFT,\n            flags: {\n                authorized: false\n            }\n        }))\n        // add the hash of the saNFT#owner_seq on the IPFS server to the data of the issuer account associating it to the buyer (EX: user1 has bought the sanft as 4th owner). This will also be used for a future functionality.\n        .addOperation(Operation.manageData({\n            name: `${userPK}.${user_owned_sanfts}`,\n            value: saNFT_hash.toString(),\n            source: issuerPK \n        }))\n    \n    // paying each owner depending on the percentage of the owned saNFT network of that owner.\n    owners.forEach((owner) => {\n        const amount = Math.round((((buy_offer-artistFee) * owner.ownPerc) / 100) * 1000000) / 1000000\n        if (amount > 0) {\n            transaction.addOperation(Operation.payment({\n                destination: owner.ownerPK,\n                    asset: Asset.native(),\n                    amount: amount.toString(),\n                    source: issuerPK\n                    }))\n                }\n            })\n    \n    // Fund pool account\n    transaction.addOperation(Operation.payment({\n        destination: poolPK,\n        asset: Asset.native(),\n        amount: poolAmount.toString(),\n        source: issuerPK\n    }))\n\n    transaction = await transaction.build()\n    return transaction.toXDR()\n\n}",
    "fields": [
    {
    "name": "paramName",
    "type": "string",
    "description": "This is a param",
    "rule": "Required"
    }
    ],
    "signer": "GCCGEGVONILIE5ZV4EMXYKSAJJLXAFTLTKM2VUYQFAM4XGGSYDQVKC3V"
    }